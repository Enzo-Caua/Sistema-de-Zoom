module controlador_JER (
   input  wire clock,          // 50 MHz
   input  wire reset,
	input  wire [5:0] instrucao,
   //input  wire [3:0] chave_alg,
   //input  wire [1:0] chave_zoom,
   output wire hsync,
   output wire vsync,
   output wire [7:0] red,
   output wire [7:0] green,
   output wire [7:0] blue,
   output wire sync,
   output wire clk,
   output wire blank
);

   // ========= PARÂMETROS FIXOS =========
   parameter ORIG_WIDTH  = 160;
   parameter ORIG_HEIGHT = 120;
   parameter VGA_WIDTH   = 640;
   parameter VGA_HEIGHT  = 480;
	
	// ========= DECODIFICADOR DE INSTRUÇAO =========
	wire [3:0] chave_alg;
   wire [1:0] chave_zoom;
	
	assign chave_alg = instrucao[3:0];
	assign chave_zoom = instrucao[5:4];
   
   // ========= Divisor de Frequência =========
   wire clock_25MHz;
   divisor_freq clk_25MHZ (
      .clk_in(clock),
      .reset(reset),
      .clk_out(clock_25MHz)
   );

   // ========= Detecção de Mudança de Configuração =========
   reg [5:0] config_anterior;
   wire config_mudou;
   wire [5:0] config_atual = {chave_alg, chave_zoom};
   
   assign config_mudou = (config_atual != config_anterior);
   
   always @(posedge clock_25MHz) begin
      if (reset) begin
         config_anterior <= 6'b000000;
      end else begin
         config_anterior <= config_atual;
      end
   end

   // ========= Estados para Média de Blocos - EXPANDIDO =========
   reg [4:0] estado_media;     // EXPANDIDO: 5 bits para até 16 estados
   reg [15:0] soma_pixels;     // EXPANDIDO: 16 bits para 16 pixels
   reg [7:0] pixel_ram_in_delayed;
   reg [7:0] pixel_final;
   
   // Detecta tipo de média de blocos
   wire usar_media_2x = (chave_alg == 4'b1000) && (chave_zoom == 2'b01);
   wire usar_media_4x = (chave_alg == 4'b1000) && (chave_zoom == 2'b10);
   wire usar_media_blocos = usar_media_2x || usar_media_4x;

   // ========= Define largura e altura de acordo com chaves =========
   reg [9:0] largura_imagem, altura_imagem;
   wire [9:0] largura_destino, altura_destino;
   
   always @(posedge clock_25MHz) begin
      if (reset) begin
         largura_imagem <= ORIG_WIDTH;
         altura_imagem  <= ORIG_HEIGHT;
      end else begin
         case ({chave_alg, chave_zoom})
            // Zoom In - 2x
            6'b000101, 6'b001001: begin
               largura_imagem <= ORIG_WIDTH << 1;  // 320
               altura_imagem  <= ORIG_HEIGHT << 1; // 240
            end
            // Zoom Out - 2x
            6'b010001, 6'b100001: begin
               largura_imagem <= ORIG_WIDTH >> 1;  // 80
               altura_imagem  <= ORIG_HEIGHT >> 1; // 60
            end
            // Zoom In - 4x
            6'b000110, 6'b001010: begin
               largura_imagem <= ORIG_WIDTH << 2;  // 640
               altura_imagem  <= ORIG_HEIGHT << 2; // 480
            end
            // Zoom Out - 4x
            6'b010010, 6'b100010: begin
               largura_imagem <= ORIG_WIDTH >> 2;  // 40
               altura_imagem  <= ORIG_HEIGHT >> 2; // 30
            end
            // Zoom 1x (padrão)
            default: begin
               largura_imagem <= ORIG_WIDTH;
               altura_imagem  <= ORIG_HEIGHT;
            end
         endcase
      end
   end
   
   // Limita as dimensões ao máximo do VGA
   assign largura_destino = (largura_imagem > VGA_WIDTH) ? VGA_WIDTH : largura_imagem;
   assign altura_destino = (altura_imagem > VGA_HEIGHT) ? VGA_HEIGHT : altura_imagem;

   // ========= Contadores para Preenchimento RAM =========
   wire [9:0] cont_x_wire, cont_y_wire;
   wire done_x, done_y;
   wire enable_contador;
   wire pixel_pronto;
   
   assign pixel_pronto = usar_media_blocos ? (estado_media == 5'd0) : 1'b1;
   assign enable_contador = usar_media_blocos ? pixel_pronto : 1'b1;

   contador_largura cont_larg (
      .clock(clock_25MHz),
      .reset(reset),
      .enable(enable_contador),
      .config_mudou(config_mudou),
      .largura_max(largura_destino),
      .cont_largura(cont_x_wire),
      .done(done_x)
   );

   contador_altura cont_alt (
      .clock(clock_25MHz),
      .reset(reset),
      .enable(done_x && enable_contador),
      .config_mudou(config_mudou),
      .altura_max(altura_destino),
      .cont_altura(cont_y_wire),
      .done(done_y)
   );

   // ========= Registradores de coordenadas processadas =========
   reg [9:0] x_proc, y_proc;
   always @(posedge clock_25MHz) begin
      if (reset || config_mudou) begin
         x_proc <= 0;
         y_proc <= 0;
      end else begin
         x_proc <= cont_x_wire;
         y_proc <= cont_y_wire;
      end
   end

   // ========= Estado: 0 = Preenchimento RAM, 1 = Exibição VGA =========
   reg modo_vga;
   always @(posedge clock_25MHz) begin
      if (reset || config_mudou)
         modo_vga <= 0;
      else if (x_proc == (largura_destino - 1) && y_proc == (altura_destino - 1))
         modo_vga <= 1;
   end

   // ========= Seletor de Algoritmo - EXPANDIDO =========
   wire [9:0] x_dest, y_dest;
   wire [9:0] x_fonte0, y_fonte0, x_fonte1, y_fonte1, x_fonte2, y_fonte2, x_fonte3, y_fonte3;
   wire [9:0] x_fonte4, y_fonte4, x_fonte5, y_fonte5, x_fonte6, y_fonte6, x_fonte7, y_fonte7;
   wire [9:0] x_fonte8, y_fonte8, x_fonte9, y_fonte9, x_fonte10, y_fonte10, x_fonte11, y_fonte11;
   wire [9:0] x_fonte12, y_fonte12, x_fonte13, y_fonte13, x_fonte14, y_fonte14, x_fonte15, y_fonte15;
   
   assign x_dest = modo_vga ? x_proc : cont_x_wire;
   assign y_dest = modo_vga ? y_proc : cont_y_wire;

   seletor_algoritmo seletor (
      .reset(reset),
      .chave_alg(chave_alg),
      .chave_zoom(chave_zoom),
      .x_destino(x_dest),
      .y_destino(y_dest),
      .x_fonte0(x_fonte0), .y_fonte0(y_fonte0),
      .x_fonte1(x_fonte1), .y_fonte1(y_fonte1),
      .x_fonte2(x_fonte2), .y_fonte2(y_fonte2),
      .x_fonte3(x_fonte3), .y_fonte3(y_fonte3),
      .x_fonte4(x_fonte4), .y_fonte4(y_fonte4),
      .x_fonte5(x_fonte5), .y_fonte5(y_fonte5),
      .x_fonte6(x_fonte6), .y_fonte6(y_fonte6),
      .x_fonte7(x_fonte7), .y_fonte7(y_fonte7),
      .x_fonte8(x_fonte8), .y_fonte8(y_fonte8),
      .x_fonte9(x_fonte9), .y_fonte9(y_fonte9),
      .x_fonte10(x_fonte10), .y_fonte10(y_fonte10),
      .x_fonte11(x_fonte11), .y_fonte11(y_fonte11),
      .x_fonte12(x_fonte12), .y_fonte12(y_fonte12),
      .x_fonte13(x_fonte13), .y_fonte13(y_fonte13),
      .x_fonte14(x_fonte14), .y_fonte14(y_fonte14),
      .x_fonte15(x_fonte15), .y_fonte15(y_fonte15)
   );

   // ========= Multiplexador de Coordenadas para ram_in - EXPANDIDO =========
   wire [9:0] x_ram_in_select, y_ram_in_select;
   reg [9:0] x_atual, y_atual;
   
   // Seleciona qual pixel ler baseado no estado - EXPANDIDO
   always @(*) begin
      if (usar_media_4x) begin
         case (estado_media)
            5'd1:  begin x_atual = x_fonte0;  y_atual = y_fonte0;  end
            5'd2:  begin x_atual = x_fonte1;  y_atual = y_fonte1;  end
            5'd3:  begin x_atual = x_fonte2;  y_atual = y_fonte2;  end
            5'd4:  begin x_atual = x_fonte3;  y_atual = y_fonte3;  end
            5'd5:  begin x_atual = x_fonte4;  y_atual = y_fonte4;  end
            5'd6:  begin x_atual = x_fonte5;  y_atual = y_fonte5;  end
            5'd7:  begin x_atual = x_fonte6;  y_atual = y_fonte6;  end
            5'd8:  begin x_atual = x_fonte7;  y_atual = y_fonte7;  end
            5'd9:  begin x_atual = x_fonte8;  y_atual = y_fonte8;  end
            5'd10: begin x_atual = x_fonte9;  y_atual = y_fonte9;  end
            5'd11: begin x_atual = x_fonte10; y_atual = y_fonte10; end
            5'd12: begin x_atual = x_fonte11; y_atual = y_fonte11; end
            5'd13: begin x_atual = x_fonte12; y_atual = y_fonte12; end
            5'd14: begin x_atual = x_fonte13; y_atual = y_fonte13; end
            5'd15: begin x_atual = x_fonte14; y_atual = y_fonte14; end
            5'd16: begin x_atual = x_fonte15; y_atual = y_fonte15; end
            default: begin x_atual = x_fonte0; y_atual = y_fonte0; end
         endcase
      end else if (usar_media_2x) begin
         case (estado_media)
            5'd1: begin x_atual = x_fonte0; y_atual = y_fonte0; end // p00
            5'd2: begin x_atual = x_fonte1; y_atual = y_fonte1; end // p01  
            5'd3: begin x_atual = x_fonte4; y_atual = y_fonte4; end // p10
            5'd4: begin x_atual = x_fonte5; y_atual = y_fonte5; end // p11
            default: begin x_atual = x_fonte0; y_atual = y_fonte0; end
         endcase
      end else begin
         x_atual = x_fonte0;
         y_atual = y_fonte0;
      end
   end
   
   assign x_ram_in_select = usar_media_blocos ? x_atual : x_fonte0;
   assign y_ram_in_select = usar_media_blocos ? y_atual : y_fonte0;

   // ========= Validação de Coordenadas =========
   wire [9:0] x_fonte_valido, y_fonte_valido;
   assign x_fonte_valido = (x_ram_in_select < ORIG_WIDTH) ? x_ram_in_select : (ORIG_WIDTH - 1);
   assign y_fonte_valido = (y_ram_in_select < ORIG_HEIGHT) ? y_ram_in_select : (ORIG_HEIGHT - 1);

   // ========= Endereço ram_in =========
   reg [14:0] endereco_ram_in;
   always @(posedge clock_25MHz) begin
      if (reset) begin
         endereco_ram_in <= 0;
      end else begin
         endereco_ram_in <= y_fonte_valido * ORIG_WIDTH + x_fonte_valido;
      end
   end

   wire [7:0] pixel_ram_in;
   ram_in ram_in_inst (
      .clock(clock_25MHz),
      .address(endereco_ram_in),
		.data(0),
		.wren(0),
      .q(pixel_ram_in)
   );

   // ========= Máquina de Estados para Média de Blocos - EXPANDIDA =========
   always @(posedge clock_25MHz) begin
      if (reset || config_mudou) begin
         estado_media <= 5'd0;
         soma_pixels <= 16'd0;
      end else if (!modo_vga && usar_media_blocos) begin
			if (usar_media_4x) begin
            // Estados 1-16 para zoom 4x (16 pixels)
            case (estado_media)
               5'd0: begin // Idle - inicia leitura do bloco 4x4
                  if ((y_proc < altura_destino) && (x_proc < largura_destino)) begin
                     estado_media <= 5'd1;
                     soma_pixels <= 16'd0;
                  end
               end
               5'd1: begin // Pixel 0
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd2;
               end
               5'd2: begin // Pixel 1
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd3;
               end
               5'd3: begin // Pixel 2
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd4;
               end
               5'd4: begin // Pixel 3
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd5;
               end
               5'd5: begin // Pixel 4
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd6;
               end
               5'd6: begin // Pixel 5
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd7;
               end
               5'd7: begin // Pixel 6
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd8;
               end
               5'd8: begin // Pixel 7
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd9;
               end
               5'd9: begin // Pixel 8
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd10;
               end
               5'd10: begin // Pixel 9
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd11;
               end
               5'd11: begin // Pixel 10
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd12;
               end
               5'd12: begin // Pixel 11
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd13;
               end
               5'd13: begin // Pixel 12
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd14;
               end
               5'd14: begin // Pixel 13
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd15;
               end
               5'd15: begin // Pixel 14
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd16;
               end
               5'd16: begin // Pixel 15 - calcula média e volta ao idle
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd0;
               end
               default: estado_media <= 5'd0;
            endcase
         end else if (usar_media_2x) begin
            // Estados 1-4 para zoom 2x (4 pixels) - mantém compatibilidade
            case (estado_media)
               5'd0: begin // Idle
                  if ((y_proc < altura_destino) && (x_proc < largura_destino)) begin
                     estado_media <= 5'd1;
                     soma_pixels <= 16'd0;
                  end
               end
               5'd1: begin // Leu pixel 0 (p00)
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd2;
               end
               5'd2: begin // Leu pixel 1 (p01)  
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd3;
               end
               5'd3: begin // Leu pixel 2 (p10)
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd4;
               end
               5'd4: begin // Leu pixel 3 (p11) - calcula média
                  soma_pixels <= soma_pixels + {8'b00000000, pixel_ram_in_delayed};
                  estado_media <= 5'd0; // Volta ao idle
               end
               default: estado_media <= 5'd0;
            endcase
         end
      end else if (!usar_media_blocos) begin
         estado_media <= 5'd0;
         soma_pixels <= 16'd0;
      end
   end

   // ========= Pipeline para ram_in e Cálculo de Média - EXPANDIDO =========
   wire [7:0] pixel_media_calculado;
   wire [15:0] soma_com_arredondamento;
   
   // Arredondamento: para 4x adiciona 8, para 2x adiciona 2
   assign soma_com_arredondamento = usar_media_4x ? (soma_pixels + 16'd8) : (soma_pixels + 16'd2);
   assign pixel_media_calculado = usar_media_4x ? soma_com_arredondamento[15:4] : soma_com_arredondamento[9:2];
   
   always @(posedge clock_25MHz) begin
      if (reset) begin
         pixel_ram_in_delayed <= 0;
         pixel_final <= 0;
      end else begin
         pixel_ram_in_delayed <= pixel_ram_in;
         
         // Seleciona pixel final baseado no algoritmo
         if (usar_media_4x && estado_media == 5'd16) begin
            pixel_final <= pixel_media_calculado;
         end else if (usar_media_2x && estado_media == 5'd4) begin
            pixel_final <= pixel_media_calculado;
         end else if (!usar_media_blocos) begin
            pixel_final <= pixel_ram_in_delayed;
         end
         // Caso contrário, mantém valor anterior
      end
   end

   // ========= RAM com Pipeline =========
   reg [18:0] endereco_RAM_wr;
   reg [7:0] pixel_RAM_wr;
   reg wren;
   wire [7:0] pixel_RAM_rd;
   reg [18:0] endereco_RAM_rd;

   ram1p RAM_inst (
      .address(wren ? endereco_RAM_wr : endereco_RAM_rd),
      .clock(clock_25MHz),
      .data(pixel_RAM_wr),
      .wren(wren),
      .q(pixel_RAM_rd)
   );

   // ========= Escrita na RAM - MODIFICADA =========
   always @(posedge clock_25MHz) begin
      if (reset || config_mudou) begin
         endereco_RAM_wr <= 0;
         pixel_RAM_wr    <= 0;
         wren            <= 0;
      end else if (!modo_vga) begin
      // Valida endereço antes de escrever
			if ((y_proc < altura_destino) && (x_proc < largura_destino)) begin
            if (usar_media_4x) begin
               // Escreve apenas quando a média 4x4 estiver pronta
               if (estado_media == 5'd16) begin
                  pixel_RAM_wr    <= pixel_final;
                  endereco_RAM_wr <= y_proc * largura_destino + x_proc;
                  wren            <= 1;
               end else begin
                  wren <= 0;
               end
            end else if (usar_media_2x) begin
               // Escreve apenas quando a média 2x2 estiver pronta
               if (estado_media == 5'd4) begin
                  pixel_RAM_wr    <= pixel_final;
                  endereco_RAM_wr <= y_proc * largura_destino + x_proc;
                  wren            <= 1;
               end else begin
                  wren <= 0;
               end
            end else begin
               // Algoritmos normais (não média)
               pixel_RAM_wr    <= pixel_final;
               endereco_RAM_wr <= y_proc * largura_destino + x_proc;
               wren            <= 1;
            end
         end else begin
            wren <= 0;
         end
      end else begin
         wren <= 0;
      end
   end

   // ========= Leitura RAM → VGA =========
   reg [9:0] vga_x, vga_y;
   wire [9:0] prox_x, prox_y;
   reg [7:0] pixel_vga;
   reg [7:0] pixel_vga_delayed;

   // Pipeline adicional para VGA
   always @(posedge clock_25MHz) begin
      if (reset) begin
         pixel_vga_delayed <= 0;
      end else begin
         pixel_vga_delayed <= pixel_RAM_rd;
      end
   end

   always @(posedge clock_25MHz) begin
      if (reset || config_mudou) begin
         vga_x <= 0;
         vga_y <= 0;
         endereco_RAM_rd <= 0;
         pixel_vga <= 0;
      end else if (modo_vga) begin
         vga_x <= prox_x;
         vga_y <= prox_y;

         // Verifica se está dentro da área da imagem
         if ((prox_x < largura_destino) && (prox_y < altura_destino)) begin
            endereco_RAM_rd <= prox_y * largura_destino + prox_x;
            pixel_vga <= pixel_vga_delayed;
         end else begin
            endereco_RAM_rd <= 0;
            pixel_vga <= 8'b00000000; // Fundo preto
         end
      end else begin
         vga_x <= 0;
         vga_y <= 0;
         endereco_RAM_rd <= 0;
         pixel_vga <= 0;
      end
   end

   // ========= Driver VGA =========
   vga_driver ctrl_VGA (
      .clock(clock_25MHz),
      .reset(reset),
      .color_in(pixel_vga),
      .next_x(prox_x),
      .next_y(prox_y),
      .hsync(hsync),
      .vsync(vsync),
      .red(red),
      .green(green),
      .blue(blue),
      .sync(sync),
      .clk(clk),
      .blank(blank)
   );

endmodule